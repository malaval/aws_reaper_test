import copy
import logging
import time

from aws_reaper.common.base_execution_plan import BaseExecutionPlan
from aws_reaper.common.exceptions import AwsReaperException

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


class ExecutionPlanStep:
    """
    Represent a step in an execution plan defined by a service, a region and a resource type.

    """

    def __init__(self, input_dict=None):
        """
        Create an ExecutionPlanStep object by initializing a new object instance and loading the
        object from a dict.

        Args:
            input_dict (dict): Step content as generated by ``export``

        """
        if input_dict is None:
            self.service = ''
            self.region = ''
            self.resource_type = ''
            self.dependencies = []  # List of dependencies with other steps
            self.status = 'NotStarted'  # Possible values: NotStarted, Ongoing or Completed
            self.start_time = 0
            # Will be populated with the current timestamp when we start processing this step
            self.create_error = ''  # Will be populated with the error message if create failed
            self.resources_created = {}
            self.resources_required = []
        else:
            try:
                self.service = input_dict['Service']
                self.region = input_dict['Region']
                self.resource_type = input_dict['ResourceType']
                self.dependencies = input_dict['CreateBefore']
                self.status = input_dict['Status']
                self.start_time = input_dict['StartTime']
                self.create_error = input_dict['CreateError']
                self.resources_created = input_dict['ResourcesCreated']
                self.resources_required = input_dict['ResourcesFailed']
            except Exception as e:
                message = 'Cannot load step from dict: %s' % str(e)
                logger.fatal(message)
                raise AwsReaperException(message)

    @property
    def step_key(self):
        return str('%s:%s:%s') % (self.service, self.region, self.resource_type)

    def export(self, full=True):
        if full:
            return {
                'Service': self.service,
                'Region': self.region,
                'ResourceType': self.resource_type,
                'CreateBefore': self.dependencies,
                'Status': self.status,
                'StartTime': self.start_time,
                'CreateError': self.create_error,
                'ResourcesCreated': self.resources_created,
                'ResourcesRequired': self.resources_required
            }
        else:
            return {
                'Service': self.service,
                'Region': self.region,
                'ResourceType': self.resource_type,
                'CreateBefore': self.dependencies,
            }


class ExecutionPlan(BaseExecutionPlan):
    """
    Inherit from BaseExecutionPlan to create an execution plan that defines what test
    resources to create and in which order.

    """

    def __init__(
            self, loader, step_class=ExecutionPlanStep, override_botocore_regions=False,
            input_dict=None
    ):
        BaseExecutionPlan.__init__(
            self, loader, step_class, override_botocore_regions=override_botocore_regions,
            input_dict=input_dict
        )

    def populate_plan(self, included_patterns):
        """
        Populate the execution plan.

        Args:
            included_patterns (list): List of patterns of resources to include in the form of A:B:C
                with A "*" of a service name, B "*" or a region name, C "*" or a resource type
                name. Default is ["*:*:*"] to create all possible resources.

        """
        # Parse included_patterns and excluded_patterns
        try:
            included = [i.split(':') for i in included_patterns]
            assert all(len(i) == 3 for i in included)
        except Exception:
            message = 'Unable to parse included patterns'
            logger.fatal(message)
            raise AwsReaperException(message)

        for service in self._loader.list_services():
            for resource_type in self._loader.list_resource_types(service):
                for region in self.get_regions_for_service(service):

                    # Continue only if (service, region and resource_type) matches at least one
                    # included_patterns
                    if not any(
                        i_service in ('*', service)
                        and i_region in ('*', region)
                        and i_resource_type in ('*', resource_type)
                        for i_service, i_region, i_resource_type in included
                    ):
                        continue

                    # Add a step into the execution plan
                    step = self.add_step(service, region, resource_type)

        # The resources that are explicitly listed in included_patterns may be dependent to
        # other resources. For example, a VPC is needed to create an RDS instance). We add into
        # the execution plan steps to create these required resources, by iterating on the plan
        # until there is no resource type in a 'CreateBefore' attribute that is not a
        # step.
        while True:
            steps_to_add = []
            for step in self.get_steps().values():
                for d_step_key in step.dependencies:
                    if d_step_key not in self._steps.keys():
                        service, region, resource_type = d_step_key.split(':')
                        steps_to_add.append((service, region, resource_type))
            for step_to_add in steps_to_add:
                self.add_step(*step_to_add)
            if len(steps_to_add) == 0:
                break

    def get_next_step(self):
        """
        Return the next step to process.

        Returns:
            step_key: Step key to process, ``wait`` if the ongoing steps must complete before
                the remaining steps can be processed, or ``end`` if no other step has to
                be processed.
            step: ExecutionPlanStep object to process, or None if step_key is ``wait`` or
                ``end``.

        """
        # If a step has not yet started, check if all its dependencies are completed before
        # processing the step.
        for step_key, step in self._steps.items():
            if step.status == 'NotStarted':

                # If a step is NotStarted, check if all its dependencies are completed before
                # processing that step.
                dependencies_completed = all(
                    self._steps[d_step_key].status == 'Completed'
                    and self._steps[d_step_key].create_error == ''
                    for d_step_key in step.dependencies
                )
                dependencies_failed = any(
                    self._steps[d_step_key].status == 'Completed'
                    and self._steps[d_step_key].create_error != ''
                    for d_step_key in step.dependencies
                )

                # Process the step if all its dependencies are completed
                if dependencies_completed and not dependencies_failed:
                    step.status = 'Ongoing'
                    if step.start_time == 0:
                        step.start_time = int(time.time())

                    # Copy the resource identifiers that were created by other steps and that are
                    # required for the current step in step.resources_required
                    for d_step_key in step.dependencies:
                        service, region, resource_type = d_step_key.split(':')
                        resources_created = self._steps[d_step_key].resources_created
                        for r_created_key, r_created_value in resources_created.items():
                            r_required_key = '%s:%s:%s' % (service, resource_type, r_created_key)
                            step.resources_required[r_required_key] = r_created_value
                    return step_key, step

                # If any dependencies failed, we don't even try to process that step
                if dependencies_failed:
                    step.status = 'Completed'
                    step.create_error = 'Dependencies failed to create'

        # Return "wait" if there are still steps to process but dependencies are not yet completed.
        if any(step.status == 'NotStarted' for step in self._steps.values()):
            return 'wait', None

        # If the function hasn't returned yet, there is no more step to process, so we return None.
        return 'end', None
